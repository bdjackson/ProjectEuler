#!/usr/bin/env python 
# ============================================================================
import sys
import math
import primes

#  ===========================================================================
#  = http://projecteuler.net/problem=27                                      =
#  = - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - =
#  = Find the product of the coefficients, a and b, for the quadratic        =
#  = expression that produces the maximum number of primes for consecutive   =
#  = values of n, starting with n = 0.                                       =
#  = Consider quadratics of the form:                                        =
#  =    n^2+a*n+b                                                            =
#  = where:                                                                  =
#  =    |a|<1000                                                             =
#  =    |b|<1000                                                             =
#  ===========================================================================

# -----------------------------------------------------------------------------
def findMaxConsecutivePrimes(a_max, b_max):
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # probably over-estimating upper bound by a lot, but, let's be safe for now
  primes_seive = primes.getPrimeSeive(a_max*b_max)

  combos = []
  # primes are all positive, so we can ignore negative values of b which 
  # produce a negative number for the 0'th element in the sequence
  for b in xrange(b_max):
    # the 0'th entry of is always = b, so b must be prime or else there are
    # no primes generated by this pair
    if primes_seive[b] == 0: continue
    for a in xrange(-a_max+1, a_max):
      # the second (n=1) element in the sequence is equal to 1+a+b, let's 
      # throw out the pairs that produce numbers less than 1 for this entry
      if a+b+2<2: continue
      combos.append({'still_valid':True, 'num_primes':0, 'a':a, 'b':b})

  print 'Generated %d pairs after first pass' % len(combos)
  found_max_generator = False
  n = -1
  while not found_max_generator:
    n+=1
    n_sq = n**2
    num_valid = 0
    for c in combos:
      if not c['still_valid']:
        continue
      if primes_seive[(n_sq + c['a']*n + c['b'])] == 0:
        c['still_valid'] = False 
      else:
        c['num_primes'] += 1
        num_valid += 1
    assert(num_valid > 0)
    if num_valid == 1:
      found_max_generator = True
    print 'n = %d -- %d combos left' % (n, num_valid)
  
  # found max generator - now pick it out of the list
  # print combos
  optimal_a = 0
  optimal_b = 0
  for c in combos:
    if c['still_valid']:
      optimal_a = c['a']
      optimal_b = c['b']
      break
  print 'The optimal choice of a (|a|<%d) and b (|b|<%d) are:' % (a_max, b_max)
  print '\ta: %d\n\tb: %d' % (optimal_a, optimal_b)
  print 'Giving a product a*b of %d' % (optimal_a*optimal_b)

# ============================================================================
def main():
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
  findMaxConsecutivePrimes(10, 10)
  print '========================================'
  findMaxConsecutivePrimes(50, 50)
  print '========================================'
  findMaxConsecutivePrimes(1000, 1000)
  print '========================================'

# ============================================================================
if __name__ == "__main__":
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  sys.exit( main() )

# ============================================================================
# ============
# = solution =
# ============
# -59231

